{"version":3,"file":"layout.js","sources":["webpack/universalModuleDefinition","webpack/bootstrap","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/node_modules/webpack/buildin/global.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/constants/defaults.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/data-adapters/data-parser.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/data-adapters/html-data.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/drawing-manager/drawingManager.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-component/dummy-component.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-component/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-component/layoutComponent.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/layout-model/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/layout-model/layout-model.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/tree/Node.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/tree/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/utils/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/utils/utils.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-manager/layout-def.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-manager/layoutManager.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/models/data-point.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/renderers/html-renderer.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/renderers/renderer.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/utils/utils.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"layout\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"layout\"] = factory();\n\telse\n\t\troot[\"layout\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","const DEFAULT_BORDER_COLOR = 'cyan';\nconst DEFAULT_BORDER_WIDTH = '2px';\nconst DEFAULT_WIDTH = 600;\nconst DEFAULT_HEIGHT = 400;\nconst LAYOUT_ID = 'd2ad88af-7050-4c1c-b407-42745cfe3bd7';\nconst LAYOUT_NAME = 'fusionBoardLayout';\n\nexport { DEFAULT_BORDER_COLOR, DEFAULT_BORDER_WIDTH, DEFAULT_WIDTH, DEFAULT_HEIGHT, LAYOUT_ID, LAYOUT_NAME };\n\n/**\n * Hello\n */","\nimport { DataPoint } from '../models/data-point';\n\nexport class DataParser {\n  constructor(data) {\n    this.data = data;\n  }\n\n  defaultDataPointLogic() {\n    let nodepoints = [];\n    this.getnodePoints(this.data, nodepoints);\n    return nodepoints;\n  }\n\n  getnodePoints(node, nodepoints) {\n    let datapoint = new DataPoint(node);\n    nodepoints.push(datapoint);\n    node.children.forEach(child => {\n      this.getnodePoints(child, nodepoints);\n    });\n  }\n}","/* eslint no-useless-constructor: \"off\" */\nimport { DataParser } from './data-parser';\n\nexport class HTMLDataAdapter extends DataParser {\n  constructor(data) {\n    super(data);\n  }\n\n  getCoordinates() {\n    return super.defaultDataPointLogic();\n  }\n}","\nimport { HTMLRenderer } from '../renderers/html-renderer';\nimport { Utils } from '../utils/utils';\nexport class DrawingManager {\n  constructor(data, renderer, container) {\n    this.data = data;\n    this.renderer = renderer;\n    global.__renderer = renderer; // TODO change global into diff place\n    this.renderer_id = !Utils.isDOMElement(container) ? container : Utils.getID(container);\n  }\n\n  draw() {\n    switch (this.renderer) {\n      case 'html':\n        this.renderHTML();\n        break;\n    }\n  }\n\n  renderHTML() {\n    let renderer = new HTMLRenderer(this.data);\n    renderer.createhtml(this.renderer_id);\n  }\n\n  customiseNode(node, borderColor, borderWidth) {\n    if (Utils.isDOMElement(node)) {\n      Utils.highLightNode(node, borderColor, borderWidth);\n    } else {\n      Utils.highLightNode(document.getElementById(node), borderColor, borderWidth);\n    }\n  }\n\n  resetNode(container) {\n    Utils.unHighLightNode(Utils.isDOMElement(container) ? container : document.getElementById(container));\n  }\n}","import { DummyComponent, LayoutComponent } from './layout-component';\nimport LayoutManager from './layout-manager/layoutManager';\n\nexport { LayoutManager, DummyComponent, LayoutComponent };","/* eslint-disable require-jsdoc */\n\n/* eslint no-undef: \"off\" */\n\nimport LayoutComponent from './layoutComponent';\n\nclass DummyComponent extends LayoutComponent {\n  constructor(seed, dimensions) {\n    super(seed, dimensions);\n    this.seed = seed;\n  }\n\n  getLogicalSpace() {\n    return {\n      width: this.boundBox.width - 2 * this.seed,\n      height: this.boundBox.height - 2 * this.seed\n    };\n  }\n\n  setSpatialConfig(conf) {\n    this.boundBox.top = conf.y;\n    this.boundBox.left = conf.x;\n\n    this.boundBox.newDimensions = {\n      width: conf.width,\n      height: conf.height\n    };\n    this.renderAt = conf.renderAt;\n  }\n\n  set componentName(name) {\n    this._componentName = name;\n  }\n\n  get componentName() {\n    return this._componentName;\n  }\n\n  set chartComponent(componentObj) {\n    this._component = componentObj;\n  }\n\n  get chartComponent() {\n    return this._chartComponent;\n  }\n\n  draw() {\n    if (!this.component) {\n      throw new Error(`Component not set for ${this.componentName}`);\n    }\n    this.component.mount(document.getElementById(this.renderAt)); // Change the draw method to component draw\n  }\n}\n\nexport default DummyComponent;","import DummyComponent from './dummy-component';\nimport LayoutComponent from './layoutComponent';\n\nexport { DummyComponent, LayoutComponent };","export default class LayoutComponent {\n  constructor(seed, dimensions) {\n    this.seed = seed;\n    this.boundBox = {};\n    this.boundBox.height = dimensions.height;\n    this.boundBox.width = dimensions.width;\n    this.boundBox.top = null;\n    this.boundBox.left = null;\n    this.chartComponent = null;\n    this.renderAt = null;\n    this.componentName = null;\n  }\n\n  getLogicalSpace() {\n    throw new Error('getLogicalSpace is not defined');\n  }\n\n  setSpatialConfig(conf) {\n    throw new Error('setSpatialSpace is not defined');\n  }\n\n  draw() {\n    throw new Error('draw is not defined');\n  }\n}","import LayoutModel from './layout-model';\n\nexport { LayoutModel };","import LayoutModel from './layout-model';\n\nexport default LayoutModel;","import Node from '../tree';\nimport { xExtraSpace, yExtraSpace, determineBoundBox } from '../utils';\n\nclass LayoutModel {\n  constructor(measurements, config) {\n    this.measurements = measurements;\n    this.config = config;\n    this.root = this.createTree(this.config, null);\n    this.setBoundBox();\n  }\n\n  createTree(config, parent) {\n    const node = new Node(config);\n    if (parent) {\n      node._parentCut = parent.getCutType();\n      parent.addChildren([node]);\n    } else {\n      this.root = node;\n    }\n    for (let lane of config.lanes) {\n      this.createTree(lane, node);\n    }\n\n    return this.root;\n  }\n\n  allocateBoundingBox(node) {\n    const totalWeight = node.children.map(child => child.model.ratioWeight).reduce((carry, val) => carry + val, 0);\n\n    node.children.forEach((child, i, children) => {\n      let lastSibling = children[i - 1];\n      let ratio = child.model.ratioWeight / totalWeight;\n\n      if (child._parentCut === 'h') {\n        child.boundBox.width = child.parent.boundBox.width;\n        child.boundBox.height = child.parent.boundBox.height * ratio;\n        child.boundBox.left = child.parent.boundBox.left;\n        child.boundBox.top = i ? lastSibling.boundBox.top + lastSibling.boundBox.height : 0;\n      } else {\n        child.boundBox.width = child.parent.boundBox.width * ratio;\n        child.boundBox.height = child.parent.boundBox.height;\n        child.boundBox.top = child.parent.boundBox.top;\n        child.boundBox.left = i ? lastSibling.boundBox.left + lastSibling.boundBox.width : 0;\n      }\n      this.allocateBoundingBox(child);\n    });\n  }\n\n  setBoundBox() {\n    this.root.boundBox = {\n      top: 0,\n      left: 0,\n      width: this.measurements.width,\n      height: this.measurements.height\n    };\n    this.allocateBoundingBox(this.root);\n  }\n\n  negotiateDimension(node) {\n    let preferred;\n    let cumultiveExtraSpaceAmt = 0;\n    let alteredDim;\n    let nonAlteredDim;\n    let childrenLength = node.children.length;\n\n    for (let index = 0; index < childrenLength; index++) {\n      let fn;\n      let extraSpaceAmt;\n      let child = node.children[index];\n\n      if (child._parentCut === 'h') {\n        fn = yExtraSpace;\n        alteredDim = 'height';\n        nonAlteredDim = 'width';\n      } else {\n        fn = xExtraSpace;\n        alteredDim = 'width';\n        nonAlteredDim = 'height';\n      }\n      // if vertical then get extra height from other node and push it to the preferred node.\n      // for horizontal cut the same thing is to be done with width\n      if (child.isPreferred()) {\n        // push extra space in sink. Execute it when all non preferred space are computed.\n        preferred = child;\n\n        continue; // eslint-disable-line no-continue\n      }\n      // reduce own height and save it in a var\n      cumultiveExtraSpaceAmt += extraSpaceAmt = fn(child);\n      child.boundBox[alteredDim] -= extraSpaceAmt;\n      // update nonaltered dim from parent for any change which happened during negotiation\n      child.boundBox[nonAlteredDim] = child.parent.boundBox[nonAlteredDim];\n\n      this.negotiateDimension(child);\n    }\n\n    if (preferred) {\n      preferred.boundBox[alteredDim] += cumultiveExtraSpaceAmt;\n      preferred.boundBox[nonAlteredDim] = preferred.parent.boundBox[nonAlteredDim];\n      this.negotiateDimension(preferred);\n    }\n  }\n\n  computePosition(node) {\n    node.children.forEach((child, i, children) => {\n      let boundBox = determineBoundBox(child.boundBox, i, children, child);\n      child.boundBox = boundBox;\n      this.computePosition(child);\n    });\n  }\n\n  setHostPosition(node) {\n    node.children.forEach(child => {\n      LayoutModel.setHostSpatialConfig(child);\n      this.setHostPosition(child);\n    });\n  }\n\n  static setHostSpatialConfig(node) {\n    let bb = node.boundBox;\n    if (node.model.host && node.model.host.setSpatialConfig) {\n      let conf = {\n        x: bb.left,\n        y: bb.top,\n        width: bb.width,\n        height: bb.height,\n        renderAt: node._id\n      };\n\n      node.model.host.setSpatialConfig(conf);\n    }\n  }\n\n  negotiate() {\n    this.negotiateDimension(this.root);\n    this.computePosition(this.root);\n    return this;\n  }\n\n  broadcast() {\n    this.setHostPosition(this.root);\n    return this;\n  }\n\n  tree() {\n    return this.root;\n  }\n}\n\nexport default LayoutModel;","import { getNodeId } from '../utils';\n\nclass Node {\n  constructor(data) {\n    this.model = data;\n    this.parent = null;\n    this.children = [];\n\n    this.boundBox = {\n      top: null,\n      left: null,\n      height: null,\n      width: null\n    };\n\n    this._id = getNodeId();\n  }\n\n  addChildren(entries) {\n    this.children.push(...entries);\n    entries.forEach(e => {\n      e.parent = this;\n    });\n  }\n\n  isRoot() {\n    return this.parent === null;\n  }\n\n  isLeaf() {\n    return !this.children.length;\n  }\n\n  getCutType() {\n    return this.model.cut;\n  }\n\n  isPreferred() {\n    return !!this.model.preferred;\n  }\n\n  /**\n     * function to search a node and update it with the config provided.\n     * @param  {Object} nodeconfig\n     */\n  updateNode(nodeconfig) {\n    if (this._id === nodeconfig._id) {\n      this.model.cut = nodeconfig.cut;\n      this.model.ratioWeight = nodeconfig.ratioWeight;\n    } else {\n      this.children.forEach(node => {\n        if (node._id === nodeconfig._id) {\n          node.model.cut = nodeconfig.cut;\n          node.model.ratioWeight = nodeconfig.ratioWeight;\n          return;\n        }\n        this.searchNode(node, nodeconfig);\n      });\n    }\n  }\n\n  // Recursive function to search a node\n  searchNode(node, nodeconfig) {\n    node.children.forEach(node1 => {\n      if (node1._id === nodeconfig._id) {\n        node1.model.cut = nodeconfig.cut;\n        node1.model.ratioWeight = nodeconfig.ratioWeight;\n      } else {\n        this.searchNode(node1, nodeconfig);\n      }\n    });\n  }\n\n  /**\n     * function to delete a node from tree Structure.\n     * @param  {String} nodeId - node Id of the Node\n     */\n  delete(nodeId) {\n    this.children.forEach(node => {\n      if (node._id === nodeId) {\n        let index = this.children.indexOf(node);\n        this.model.lanes.splice(index, 1);\n      }\n      this.deleteSearchNode(node, nodeId);\n    });\n  }\n\n  // Recursive function to search a node\n  deleteSearchNode(node, nodeId) {\n    node.children.forEach(node1 => {\n      if (node1._id === nodeId) {\n        let index = node.children.indexOf(node1);\n        node.model.lanes.splice(index, 1);\n      } else {\n        this.deleteSearchNode(node1, nodeId);\n      }\n    });\n  }\n}\n\nexport default Node;","import Node from './Node';\n\nexport default Node;","\nimport { isEqual, getNodeId, yExtraSpace, xExtraSpace, determineBoundBox, getColor } from './utils';\n\nexport { isEqual, getNodeId, yExtraSpace, xExtraSpace, determineBoundBox, getColor };","\n/**\n * Compares two strings in lowercase\n *\n * @export\n * @param {string} value the value to be compared\n * @param {string} compareTo whom the value would be compared\n * @return {boolean} true if values are equal\n */\nfunction isEqual(value, compareTo) {\n  if (typeof value !== 'string' || typeof compareTo !== 'string') {\n    throw new TypeError('value and compareTo must be string');\n  }\n  return value.toLowerCase() === compareTo.toLowerCase();\n}\n\nconst getNodeId = (() => {\n  let _uid = 0;\n  return () => `node-${++_uid}`;\n})();\n\nfunction yExtraSpace(node) {\n  let smallestHeight = 0;\n  if (node.getCutType() === 'v') {\n    smallestHeight = smallestExtraHeightHorizontally(node); // eslint-disable-line no-use-before-define\n  } else if (node.getCutType() === 'h') {\n    node.children.forEach(child => {\n      smallestHeight += yExtraSpace(child);\n    });\n  } else if (node.model.host && node.model.host.getLogicalSpace) {\n    let containerHeight = node.boundBox.height;\n    let hostHeight = node.model.host.getLogicalSpace().height;\n\n    smallestHeight = containerHeight - hostHeight;\n    if (smallestHeight < 0) {\n      smallestHeight = 0;\n    }\n  } else {\n    smallestHeight = 0;\n  }\n  return smallestHeight;\n}\n\nfunction smallestExtraHeightHorizontally(node) {\n  let smallestHeight = Number.MAX_SAFE_INTEGER;\n  node.children.forEach(child => {\n    let h = yExtraSpace(child);\n    if (h < smallestHeight) {\n      smallestHeight = h;\n    }\n  });\n  return smallestHeight;\n}\n\nfunction xExtraSpace(node) {\n  let smallestWidth = 0;\n  if (node.getCutType() === 'h') {\n    smallestWidth = smallestExtraWidthVertically(node); // eslint-disable-line no-use-before-define\n  } else if (node.getCutType() === 'v') {\n    node.children.forEach(child => {\n      smallestWidth += xExtraSpace(child);\n    });\n  } else if (node.model.host && node.model.host.getLogicalSpace) {\n    let containerWidth = node.boundBox.width;\n    let hostWidth = node.model.host.getLogicalSpace().width;\n    smallestWidth = containerWidth - hostWidth;\n    if (smallestWidth < 0) {\n      smallestWidth = 0;\n    }\n  } else {\n    smallestWidth = 0;\n  }\n  return smallestWidth;\n}\n\nfunction smallestExtraWidthVertically(node) {\n  let smallestWidth = Number.MAX_SAFE_INTEGER;\n  node.children.forEach(child => {\n    let w = xExtraSpace(child);\n    if (w < smallestWidth) {\n      smallestWidth = w;\n    }\n  });\n  return smallestWidth;\n}\n\nfunction determineBoundBox(bb, i, arr, instance) {\n  if (i) {\n    // if not first sibling, take boundbox from previous sibling\n    let lastSibling = arr[i - 1];\n    return {\n      width: bb.width,\n      height: bb.height,\n\n      top: instance._parentCut === 'h' ? lastSibling.boundBox.top + lastSibling.boundBox.height : lastSibling.boundBox.top,\n\n      left: instance._parentCut === 'h' ? lastSibling.boundBox.left : lastSibling.boundBox.left + lastSibling.boundBox.width\n    };\n  }\n  // if first sibling, take boundbox from parent\n  return {\n    width: bb.width,\n    height: bb.height,\n    top: instance.parent.boundBox.top,\n    left: instance.parent.boundBox.left\n  };\n}\n\nexport { isEqual, getNodeId, yExtraSpace, xExtraSpace, determineBoundBox, smallestExtraWidthVertically, smallestExtraHeightHorizontally };","export class LayoutDef {\n  constructor(layoutDefinition) {\n    this.componentMap = new Map();\n    this.layoutDefinition = layoutDefinition;\n  }\n\n  addComponent(component) {\n    this.componentMap.set(component.name, component);\n  }\n\n  addMultipleComponent(componentArray) {\n    componentArray.forEach(comp => {\n      this.addComponent(comp.name, comp);\n    });\n  }\n\n  getSanitizedDefinition() {\n    this.sanitizeConfig(this.layoutDefinition);\n    return this.layoutDefinition;\n  }\n\n  sanitizeConfig(hostObj) {\n    if (hostObj.lanes && hostObj.lanes.length) {\n      hostObj.lanes.forEach(childHost => this.sanitizeConfig(childHost));\n    }\n    if (hostObj.host != null && typeof hostObj.host === 'string') {\n      if (this.componentMap.get(hostObj.host) !== undefined) {\n        hostObj.host = this.componentMap.get(hostObj.host);\n      }\n    }\n  }\n\n  getComponentMap() {\n    return this.componentMap;\n  }\n}","import { LayoutModel } from '../layout-definition';\n\nimport { DEFAULT_WIDTH, DEFAULT_HEIGHT, LAYOUT_NAME } from '../constants/defaults';\n\nimport { DrawingManager } from '../drawing-manager/drawingManager';\nimport { Utils } from '../utils/utils';\nimport { LayoutDef } from './layout-def';\nimport { DummyComponent } from '../layout-component';\n\nclass LayoutManager {\n  constructor(conf) {\n    this.renderAt = conf.renderAt;\n    this.width = conf.width || DEFAULT_WIDTH;\n    this.height = conf.height || DEFAULT_HEIGHT;\n    this.skeletonType = conf.skeletonType || 'html';\n    this.layoutDefinition = conf.layoutDefinition;\n    this.layoutDef = new LayoutDef(conf.layoutDefinition);\n    if (Utils.isDOMElement(this.renderAt)) {\n      this.renderAt._layout = this;\n    } else {\n      document.getElementById(this.renderAt)._layout = this;\n    }\n  }\n\n  compute() {\n    Utils.removeDiv(LAYOUT_NAME);\n    this.layoutDefinition = this.layoutDef.getSanitizedDefinition();\n    this._layout = new LayoutModel({\n      width: this.width,\n      height: this.height\n    }, this.layoutDefinition);\n    this.tree = this._layout.negotiate().tree();\n    this._layout.broadcast();\n    this.manager = new DrawingManager(this.tree, this.skeletonType, this.renderAt);\n\n    // this will draw all the components by calling their draw method\n    this.manager.draw();\n  }\n\n  addComponent(component) {\n    this.layoutDef.addComponent(component);\n  }\n\n  addMultipleComponent(componentArray) {\n    this.layoutDef.addMultipleComponent(componentArray);\n  }\n\n  resetNode(node) {\n    if (this.con) {\n      this.con.resetNode(node);\n    }\n  }\n\n  /**\n   * function to update the node and rerender the layout.\n   * @param  {} config - node configuration to change.\n   */\n  updateNode(config) {\n    this.tree.updateNode(config);\n    this.layoutDefinition = this.tree.model;\n    this.compute();\n  }\n\n  /**\n   * This method will be private and only be used to create\n   * layout components for default chart components such as title,legend etc\n   * @param {Array<{component,name}>} rawComponents : List of Component to be added\n   */\n  _createLayoutComponents(rawComponentsContainer) {\n    let layoutComponents = [];\n    // create dummy components and add them\n    rawComponentsContainer.forEach(container => {\n      let dummy = new DummyComponent(0, container.component.getLogicalSpace());\n      dummy.component = container.component;\n      dummy.componentName = container.name;\n      layoutComponents.push(dummy);\n    });\n    this.registerComponents(layoutComponents);\n  }\n\n  /**\n  * This function takes the LayoutComponents and Register them in component store\n  * @param {Array<LayoutComponent>} layoutComponents\n  */\n  registerComponents(layoutComponents) {}\n}\n\nexport default LayoutManager;","\nexport class DataPoint {\n  constructor(node) {\n    this.top = node.boundBox.top;\n    this.left = node.boundBox.left;\n    this.width = node.boundBox.width;\n    this.height = node.boundBox.height;\n    this._id = node._id;\n    this.parent = node.parent;\n  }\n}","import { HTMLDataAdapter } from '../data-adapters/html-data';\nimport { Utils } from '../utils/utils';\nimport { Renderer } from './renderer';\nimport { LAYOUT_NAME } from '../constants/defaults';\nexport class HTMLRenderer extends Renderer {\n  constructor(data) {\n    super();\n    this.data = data;\n    this.coordinates = new HTMLDataAdapter(this.data).getCoordinates();\n  }\n\n  createhtml(id) {\n    let mainDiv = document.getElementById(id);\n    super.initRenderer(mainDiv, this.data); // Initialise node with layout id\n    let parentDiv = this.createAndCustomiseParent();\n    this.coordinates.forEach(node => {\n      parentDiv.appendChild(this.createAndPositionDiv(node));\n    });\n    mainDiv.appendChild(parentDiv);\n  }\n\n  createAndPositionDiv(node) {\n    let div = document.createElement('div');\n    div.style.position = 'absolute';\n    div.style.left = node.left + 'px';\n    div.style.top = node.top + 'px';\n    div.style.height = node.height + 'px';\n    div.style.width = node.width + 'px';\n    // div.style.border = '1px dotted red'\n    // Utils.hoverHandler(div)\n    div.id = node._id;\n    return div;\n  }\n\n  createAndCustomiseParent() {\n    let container = Utils.findContainer(this.coordinates);\n    let parentDiv = this.createAndPositionDiv(container);\n    parentDiv.id = LAYOUT_NAME;\n    parentDiv.style.position = 'relative';\n    return parentDiv;\n  }\n}","/* eslint no-useless-constructor: \"off\" */\nimport { LAYOUT_ID } from '../constants/defaults';\n\nexport class Renderer {\n  constructor() {}\n\n  initRenderer(node, tree) {\n    node.className = LAYOUT_ID;\n    node.__logicalTree = tree;\n  }\n}","/* eslint no-undef: \"off\" */\nimport { DEFAULT_BORDER_COLOR, DEFAULT_BORDER_WIDTH } from '../constants/defaults';\n\nexport class Utils {\n  static onHover(event) {\n    this.highLightNode(event.target, DEFAULT_BORDER_COLOR, DEFAULT_BORDER_WIDTH);\n  }\n\n  static offHover(event) {\n    this.unHighLightNode(event.target);\n  }\n\n  static htmlHover(node, color, width) {\n    color = color !== undefined ? color : DEFAULT_BORDER_COLOR;\n    width = width !== undefined ? width : DEFAULT_BORDER_WIDTH;\n    node.style.outline = `${color} solid ${width}`;\n  }\n\n  static htmlUnHover(node) {\n    node.style.outline = '';\n  }\n\n  static highLightNode(node, color, width) {\n    let renderer = global.__renderer;\n\n    switch (renderer) {\n      case 'html':\n        this.htmlHover(node, color, width);\n        break;\n    }\n  }\n\n  static unHighLightNode(node) {\n    let renderer = global.__renderer;\n    switch (renderer) {\n      case 'html':\n        this.htmlUnHover(node);\n        break;\n    }\n  }\n\n  static hoverHandler(container) {\n    container.addEventListener('mouseover', this.onHover.bind(this));\n    container.addEventListener('mouseleave', this.offHover.bind(this));\n  }\n\n  static isDOMElement(element) {\n    return element instanceof Element;\n  }\n\n  static getID(element) {\n    return element.id;\n  }\n\n  static findContainer(data) {\n    return data.filter(coordinate => {\n      return coordinate.parent == null;\n    })[0];\n  }\n  /**\n   * static method to remove the div\n   * @param  {} divId - div ID to be removed.\n   */\n  static removeDiv(divId) {\n    if (document.getElementById(divId) !== null) {\n      document.getElementById(divId).remove();\n    }\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;ACDA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrJA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpGA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3GA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;A","sourceRoot":""}