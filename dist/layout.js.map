{"version":3,"file":"layout.js","sources":["webpack/universalModuleDefinition","webpack/bootstrap","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/node_modules/webpack/buildin/global.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/constants/defaults.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/data-adapters/data-parser.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/data-adapters/data-point.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/data-adapters/html-data.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/drawing-manager/drawingManager.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-component/dummy-component.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-component/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-component/layoutComponent.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/definition-manager/definitionModel.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/definition-manager/defintionManager.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/definition-manager/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/layout-model/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/layout-model/layout-model.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/tree/Node.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/tree/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/utils/index.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-definition/utils/utils.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-manager/layout-def.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/layout-manager/layoutManager.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/renderers/html-renderer.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/renderers/renderer.js","/Users/ujjal/Documents/fusioncharts/fusionboard/layout/src/utils/utils.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"layout\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"layout\"] = factory();\n\telse\n\t\troot[\"layout\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","const DEFAULT_BORDER_COLOR = 'cyan';\nconst DEFAULT_BORDER_WIDTH = '2px';\nconst DEFAULT_WIDTH = 600;\nconst DEFAULT_HEIGHT = 400;\nconst LAYOUT_ID = 'd2ad88af-7050-4c1c-b407-42745cfe3bd7';\nconst LAYOUT_NAME = 'fusionBoardLayout';\n\nexport { DEFAULT_BORDER_COLOR, DEFAULT_BORDER_WIDTH, DEFAULT_WIDTH, DEFAULT_HEIGHT, LAYOUT_ID, LAYOUT_NAME };","\nimport { DataPoint } from './data-point';\n\nexport class DataParser {\n  constructor(data) {\n    this.data = data;\n  }\n\n  defaultDataPointLogic() {\n    let nodepoints = [];\n    this.getnodePoints(this.data, nodepoints);\n    return nodepoints;\n  }\n\n  getnodePoints(node, nodepoints) {\n    let datapoint = new DataPoint(node);\n    nodepoints.push(datapoint);\n    node.children.forEach(child => {\n      this.getnodePoints(child, nodepoints);\n    });\n  }\n}","\nexport class DataPoint {\n  constructor(node) {\n    this.top = node.boundBox.top;\n    this.left = node.boundBox.left;\n    this.width = node.boundBox.width;\n    this.height = node.boundBox.height;\n    this._id = node._id;\n    this.parent = node.parent;\n  }\n}","/* eslint no-useless-constructor: \"off\" */\nimport { DataParser } from './data-parser';\n\nexport class HTMLDataAdapter extends DataParser {\n  constructor(data) {\n    super(data);\n  }\n\n  getCoordinates() {\n    return super.defaultDataPointLogic();\n  }\n}","\nimport { HTMLRenderer } from '../renderers/html-renderer';\nimport { Utils } from '../utils/utils';\nexport class DrawingManager {\n  constructor(data, renderer, container) {\n    this.data = data.tree;\n    this.componentMap = data.componentMap;\n    this.renderer = renderer;\n    global.__renderer = renderer; // TODO change global into diff place\n    this.renderer_id = !Utils.isDOMElement(container) ? container : Utils.getID(container);\n  }\n\n  _drawLayout() {\n    switch (this.renderer) {\n      case 'html':\n        this.renderHTML();\n        break;\n    }\n  }\n\n  _drawComponent(componentData) {\n    componentData.children.forEach(node => {\n      if (node.model && node.model.host) {\n        node.model.host.draw();\n      }\n      this._drawComponent(node);\n    });\n  }\n\n  draw() {\n    this._drawLayout();\n    // resolve alingment\n    /**\n     * alignwith :\n     * alignment : left | right | hCenter | vCenter |default\n     * logic if Alignment is need search the div ,\n     * create a child div according to alignment,\n     * set the measurements and append it as child,\n     * (check if alignment possible)\n     * replace node id of parent with child\n     */\n    this._resolveAligment(this.data);\n    this._drawComponent(this.data);\n  }\n\n  _resolveAligment(componentData) {\n    componentData.children.forEach(component => {\n      if (component.model && component.model.host && component.model.host.alignWidth) {\n        let childNode;\n        let node = this._findNode(component._id);\n        let refNode = this._findNode(this.componentMap.get(component.model.host.alignWidth).renderAt);\n        switch (component.model.host.alignment) {\n          case 'left':\n            childNode = this._getChildNode(node.top, refNode.left, node.height, Math.abs(node.width - Math.abs(refNode.left - node.left)), node._id);\n            break;\n          case 'right':\n            childNode = this._getChildNode(node.top, node.left, node.height, Math.abs(node.width - Math.abs(node.left + node.width - (refNode.left + refNode.width))), node._id);\n            break;\n          case 'top':\n            childNode = this._getChildNode(refNode.top, node.left, Math.abs(node.height - Math.abs(refNode.top - node.top)), node.width, node._id);\n            break;\n          case 'bottom':\n            childNode = this._getChildNode(node.top, node.left, Math.abs(node.top - refNode.top + refNode.height), node.width, node._id);\n            break;\n          case 'h-center':\n            childNode = this._getChildNode(node.top, refNode.left, node.height, refNode.width, node._id);\n            break;\n          case 'v-center':\n            childNode = this._getChildNode(refNode.top, node.left, refNode.height, node.width, node._id);\n            break;\n        }\n        // check if model in parent component\n        this.componentMap.get(component.model.host.componentName).renderAt = `${component._id}-holder`;\n        this.componentRenderer.parentDiv.appendChild(childNode);\n      }\n      this._resolveAligment(component);\n    });\n  }\n\n  _getChildNode(top, left, height, width, _id) {\n    let childNodeDim = {};\n    childNodeDim.top = top;\n    childNodeDim.left = left;\n    childNodeDim.height = height;\n    childNodeDim.width = width;\n    childNodeDim._id = `${_id}-holder`;\n    return this.componentRenderer.createAndPositionDiv(childNodeDim);\n  }\n\n  _findNode(nodeID) {\n    return this.componentRenderer.coordinates.find(node => {\n      return node._id === nodeID;\n    });\n  }\n\n  renderHTML() {\n    this.componentRenderer = new HTMLRenderer(this.data);\n    this.componentRenderer.createhtml(this.renderer_id);\n  }\n\n  // customiseNode (node, borderColor, borderWidth) {\n  //   if (Utils.isDOMElement(node)) {\n  //     Utils.highLightNode(node, borderColor, borderWidth)\n  //   } else {\n  //     Utils.highLightNode(document.getElementById(node), borderColor, borderWidth)\n  //   }\n  // }\n\n  // resetNode (container) {\n  //   Utils.unHighLightNode(Utils.isDOMElement(container) ? container\n  //     : document.getElementById(container))\n  // }\n}","import { DummyComponent, LayoutComponent } from './layout-component';\nimport LayoutManager from './layout-manager/layoutManager';\n\nexport { LayoutManager, DummyComponent, LayoutComponent };","/* eslint-disable require-jsdoc */\n\n/* eslint no-undef: \"off\" */\n\nimport LayoutComponent from './layoutComponent';\n\nclass DummyComponent extends LayoutComponent {\n  constructor(seed, dimensions) {\n    super(seed, dimensions);\n    this.seed = seed;\n  }\n\n  getLogicalSpace() {\n    return {\n      width: this.boundBox.width - 2 * this.seed,\n      height: this.boundBox.height - 2 * this.seed\n    };\n  }\n\n  setSpatialConfig(conf) {\n    this.boundBox.top = conf.y;\n    this.boundBox.left = conf.x;\n\n    this.boundBox.newDimensions = {\n      width: conf.width,\n      height: conf.height\n    };\n    this.renderAt = conf.renderAt;\n  }\n\n  set componentName(name) {\n    this._componentName = name;\n  }\n\n  get componentName() {\n    return this._componentName;\n  }\n\n  set chartComponent(componentObj) {\n    this._component = componentObj;\n  }\n\n  get chartComponent() {\n    return this._chartComponent;\n  }\n\n  draw() {\n    if (!this.component) {\n      throw new Error(`Component not set for ${this.componentName}`);\n    }\n    this.component.mount(document.getElementById(this.renderAt)); // Change the draw method to component draw\n  }\n}\n\nexport default DummyComponent;","import DummyComponent from './dummy-component';\nimport LayoutComponent from './layoutComponent';\n\nexport { DummyComponent, LayoutComponent };","export default class LayoutComponent {\n  constructor(seed, dimensions) {\n    this.seed = seed;\n    this.boundBox = {};\n    this.boundBox.height = dimensions.height;\n    this.boundBox.width = dimensions.width;\n    this.boundBox.top = null;\n    this.boundBox.left = null;\n    this.chartComponent = null;\n    this.renderAt = null;\n    this.alignWidth = null;\n    this.alignment = null;\n    this.target = null;\n    this.position = null;\n    this.componentName = null;\n  }\n\n  getLogicalSpace() {\n    throw new Error('getLogicalSpace is not defined');\n  }\n\n  setSpatialConfig(conf) {\n    throw new Error('setSpatialSpace is not defined');\n  }\n\n  draw() {\n    throw new Error('draw is not defined');\n  }\n}","export default class DefinitionModel {\n  constructor(host, cut, ratioWeight, preferred, lanes) {\n    this.host = host || null;\n    this.cut = cut | 'h';\n    this.ratioWeight = ratioWeight || 1;\n    this.preferred = preferred || false;\n    this.lanes = lanes || [];\n    this._remainingHeight = 0;\n    this._remainingWidth = 0;\n  }\n  // get host () {\n  //   return this._host\n  // }\n\n  // set host (host) {\n  //   this._host = host\n  //   return this\n  // }\n  // get cut () {\n  //   return this._cut\n  // }\n\n  // set cut (cut) {\n  //   this._cut = cut\n  //   return this\n  // }\n  // get ratioWeight () {\n  //   return this._ratioWeight\n  // }\n\n  // set ratioWeight (ratioWeight) {\n  //   this._ratioWeight = ratioWeight\n  //   return this\n  // }\n  // get preferred () {\n  //   return this._preferred\n  // }\n\n  // set preferred (preferred) {\n  //   this._preferred = preferred\n  //   return this\n  // }\n  // get lanes () {\n  //   return this._lanes\n  // }\n\n  // set lanes (lanes) {\n  //   this._lanes = lanes\n  //   return this\n  // }\n\n  // set _remainingHeight (h) {\n  //   this.__remainingHeight = h\n  // }\n\n  // get _remainingHeight () {\n  //   return this.__remainingHeight\n  // }\n\n  // set _remainingWidth (w) {\n  //   this.__remainingWidth = w\n  // }\n\n  // get _remainingWidth () {\n  //   return this.__remainingWidth\n  // }\n}","import DefinitionModel from './definitionModel';\n\nexport default class DefinitionManager {\n  constructor(componentMap, totalHeight, totalWidth) {\n    this.componentMap = componentMap;\n    this.totalHeight = totalHeight;\n    this.totalWidth = totalWidth;\n  }\n\n  // prepares the targetComponent Map for target Mapping ie. where a component should lie\n  _prepareTargetComponentMap() {\n    this.targetComponentMap = new Map();\n    this.componentMap.forEach((value, key) => {\n      if (this.targetComponentMap.has(value.target)) {\n        this.targetComponentMap.get(value.target).push(value);\n      } else {\n        let temp = [];\n        temp.push(value);\n        this.targetComponentMap.set(value.target, temp);\n      }\n    });\n  }\n\n  // create the config model\n  generateConfigModel() {\n    this._prepareTargetComponentMap();\n    let canvasComponent = this.targetComponentMap.get('canvas');\n    let definitionModel = new DefinitionModel();\n    let tempDefModel = definitionModel;\n    definitionModel._remainingHeight = this.totalHeight;\n    definitionModel._remainingWidth = this.totalWidth;\n\n    let componentRef = null;\n\n    // insert title\n    componentRef = this._getComponent(canvasComponent, 'title');\n    tempDefModel = this._placeComponent(tempDefModel, componentRef);\n\n    // insert Subtitle\n    componentRef = this._getComponent(canvasComponent, 'subtitle');\n    tempDefModel = this._placeComponent(tempDefModel, componentRef);\n\n    // insert color legend\n    componentRef = this._getComponent(canvasComponent, 'colorLegend');\n    tempDefModel = this._placeComponent(tempDefModel, componentRef);\n\n    // insert shape legend\n    componentRef = this._getComponent(canvasComponent, 'shapeLegend');\n    tempDefModel = this._placeComponent(tempDefModel, componentRef);\n\n    // insert size legend\n    componentRef = this._getComponent(canvasComponent, 'sizeLegend');\n    tempDefModel = this._placeComponent(tempDefModel, componentRef);\n\n    // insert chart\n    componentRef = this._getComponent(canvasComponent, 'chart');\n    tempDefModel = this._placeComponent(tempDefModel, componentRef, true);\n    console.log(tempDefModel);\n    return definitionModel;\n  }\n\n  _getComponent(canvasComponent, componentName) {\n    let comp = canvasComponent.find(component => component.componentName === componentName);\n    return comp !== -1 ? comp : null;\n  }\n\n  /**\n   * @TODO : provide %age support\n   * @TODO : provide support for nested placement such as logo in a title\n   *\n   * @param {DefinitionModel} definitionModel\n   * @param {LayoutComponent} component\n   */\n  _placeComponent(definitionModel, component, isPreferred = false) {\n    if (component == null) {\n      return definitionModel;\n    }\n    let componentDimension = component.getLogicalSpace();\n    let componentHeight = componentDimension.height;\n    let componentWidth = componentDimension.width;\n    let cut = '';\n    let componentRatioWidth = 1;\n    let leftOvercomponentRationWidth = 1;\n    let leftHeight = 0;\n    let leftWidth = 0;\n    if (component.position === 'top' || component.position === 'bottom') {\n      cut = 'h';\n      componentRatioWidth = componentHeight / definitionModel._remainingHeight;\n      leftHeight = definitionModel._remainingHeight - componentHeight;\n      leftWidth = definitionModel._remainingWidth;\n    } else {\n      cut = 'v';\n      componentRatioWidth = componentWidth / definitionModel._remainingWidth;\n      leftWidth = definitionModel._remainingWidth - componentWidth;\n      leftHeight = definitionModel._remainingHeight;\n    }\n    leftOvercomponentRationWidth = 1 - componentRatioWidth;\n\n    // update parentModel\n    definitionModel.cut = cut;\n\n    let firstLane = new DefinitionModel(component.componentName, null, componentRatioWidth, isPreferred, []);\n    firstLane._remainingHeight = componentHeight;\n    firstLane._remainingWidth = componentWidth;\n    let secondLane = new DefinitionModel(null, null, leftOvercomponentRationWidth, !isPreferred, []);\n    secondLane._remainingHeight = leftHeight;\n    secondLane._remainingWidth = leftWidth;\n    if (isPreferred) {\n      definitionModel.lanes = [firstLane];\n    } else {\n      if (component.position === 'top' || component.position === 'left') {\n        definitionModel.lanes = [firstLane, secondLane];\n      } else {\n        definitionModel.lanes = [secondLane, firstLane];\n      }\n    }\n    return secondLane;\n  }\n}","import DefinitionManager from './defintionManager';\n\nexport default DefinitionManager;","import LayoutModel from './layout-model';\n\nexport { LayoutModel };","import LayoutModel from './layout-model';\n\nexport default LayoutModel;","import Node from '../tree';\nimport { xExtraSpace, yExtraSpace, determineBoundBox } from '../utils';\n\nclass LayoutModel {\n  constructor(measurements, config) {\n    this.measurements = measurements;\n    this.config = config;\n    this.root = this.createTree(this.config, null);\n    this.setBoundBox();\n  }\n\n  createTree(config, parent) {\n    const node = new Node(config);\n    if (parent) {\n      node._parentCut = parent.getCutType();\n      parent.addChildren([node]);\n    } else {\n      this.root = node;\n    }\n    for (let lane of config.lanes) {\n      this.createTree(lane, node);\n    }\n\n    return this.root;\n  }\n\n  allocateBoundingBox(node) {\n    const totalWeight = node.children.map(child => child.model.ratioWeight).reduce((carry, val) => carry + val, 0);\n\n    node.children.forEach((child, i, children) => {\n      let lastSibling = children[i - 1];\n      let ratio = child.model.ratioWeight / totalWeight;\n\n      if (child._parentCut === 'h') {\n        child.boundBox.width = child.parent.boundBox.width;\n        child.boundBox.height = child.parent.boundBox.height * ratio;\n        child.boundBox.left = child.parent.boundBox.left;\n        child.boundBox.top = i ? lastSibling.boundBox.top + lastSibling.boundBox.height : 0;\n      } else {\n        child.boundBox.width = child.parent.boundBox.width * ratio;\n        child.boundBox.height = child.parent.boundBox.height;\n        child.boundBox.top = child.parent.boundBox.top;\n        child.boundBox.left = i ? lastSibling.boundBox.left + lastSibling.boundBox.width : 0;\n      }\n      this.allocateBoundingBox(child);\n    });\n  }\n\n  setBoundBox() {\n    this.root.boundBox = {\n      top: 0,\n      left: 0,\n      width: this.measurements.width,\n      height: this.measurements.height\n    };\n    this.allocateBoundingBox(this.root);\n  }\n\n  negotiateDimension(node) {\n    let preferred;\n    let cumultiveExtraSpaceAmt = 0;\n    let alteredDim;\n    let nonAlteredDim;\n    let childrenLength = node.children.length;\n\n    for (let index = 0; index < childrenLength; index++) {\n      let fn;\n      let extraSpaceAmt;\n      let child = node.children[index];\n\n      if (child._parentCut === 'h') {\n        fn = yExtraSpace;\n        alteredDim = 'height';\n        nonAlteredDim = 'width';\n      } else {\n        fn = xExtraSpace;\n        alteredDim = 'width';\n        nonAlteredDim = 'height';\n      }\n      // if vertical then get extra height from other node and push it to the preferred node.\n      // for horizontal cut the same thing is to be done with width\n      if (child.isPreferred()) {\n        // push extra space in sink. Execute it when all non preferred space are computed.\n        preferred = child;\n\n        continue; // eslint-disable-line no-continue\n      }\n      // reduce own height and save it in a var\n      cumultiveExtraSpaceAmt += extraSpaceAmt = fn(child);\n      child.boundBox[alteredDim] -= extraSpaceAmt;\n      // update nonaltered dim from parent for any change which happened during negotiation\n      child.boundBox[nonAlteredDim] = child.parent.boundBox[nonAlteredDim];\n\n      this.negotiateDimension(child);\n    }\n\n    if (preferred) {\n      preferred.boundBox[alteredDim] += cumultiveExtraSpaceAmt;\n      preferred.boundBox[nonAlteredDim] = preferred.parent.boundBox[nonAlteredDim];\n      this.negotiateDimension(preferred);\n    }\n  }\n\n  computePosition(node) {\n    node.children.forEach((child, i, children) => {\n      let boundBox = determineBoundBox(child.boundBox, i, children, child);\n      child.boundBox = boundBox;\n      this.computePosition(child);\n    });\n  }\n\n  setHostPosition(node) {\n    node.children.forEach(child => {\n      LayoutModel.setHostSpatialConfig(child);\n      this.setHostPosition(child);\n    });\n  }\n\n  static setHostSpatialConfig(node) {\n    let bb = node.boundBox;\n    if (node.model.host && node.model.host.setSpatialConfig) {\n      let conf = {\n        x: bb.left,\n        y: bb.top,\n        width: bb.width,\n        height: bb.height,\n        renderAt: node._id\n      };\n\n      node.model.host.setSpatialConfig(conf);\n    }\n  }\n\n  negotiate() {\n    this.negotiateDimension(this.root);\n    this.computePosition(this.root);\n    return this;\n  }\n\n  broadcast() {\n    this.setHostPosition(this.root);\n    return this;\n  }\n\n  tree() {\n    return this.root;\n  }\n}\n\nexport default LayoutModel;","import { getNodeId } from '../utils';\n\nclass Node {\n  constructor(data) {\n    this.model = data;\n    this.parent = null;\n    this.children = [];\n\n    this.boundBox = {\n      top: null,\n      left: null,\n      height: null,\n      width: null\n    };\n\n    this._id = getNodeId();\n  }\n\n  addChildren(entries) {\n    this.children.push(...entries);\n    entries.forEach(e => {\n      e.parent = this;\n    });\n  }\n\n  isRoot() {\n    return this.parent === null;\n  }\n\n  isLeaf() {\n    return !this.children.length;\n  }\n\n  getCutType() {\n    return this.model.cut;\n  }\n\n  isPreferred() {\n    return !!this.model.preferred;\n  }\n\n  /**\n     * function to search a node and update it with the config provided.\n     * @param  {Object} nodeconfig\n     */\n  updateNode(nodeconfig) {\n    if (this._id === nodeconfig._id) {\n      this.model.cut = nodeconfig.cut;\n      this.model.ratioWeight = nodeconfig.ratioWeight;\n    } else {\n      this.children.forEach(node => {\n        if (node._id === nodeconfig._id) {\n          node.model.cut = nodeconfig.cut;\n          node.model.ratioWeight = nodeconfig.ratioWeight;\n          return;\n        }\n        this.searchNode(node, nodeconfig);\n      });\n    }\n  }\n\n  // Recursive function to search a node\n  searchNode(node, nodeconfig) {\n    node.children.forEach(node1 => {\n      if (node1._id === nodeconfig._id) {\n        node1.model.cut = nodeconfig.cut;\n        node1.model.ratioWeight = nodeconfig.ratioWeight;\n      } else {\n        this.searchNode(node1, nodeconfig);\n      }\n    });\n  }\n\n  /**\n     * function to delete a node from tree Structure.\n     * @param  {String} nodeId - node Id of the Node\n     */\n  delete(nodeId) {\n    this.children.forEach(node => {\n      if (node._id === nodeId) {\n        let index = this.children.indexOf(node);\n        this.model.lanes.splice(index, 1);\n      }\n      this.deleteSearchNode(node, nodeId);\n    });\n  }\n\n  // Recursive function to search a node\n  deleteSearchNode(node, nodeId) {\n    node.children.forEach(node1 => {\n      if (node1._id === nodeId) {\n        let index = node.children.indexOf(node1);\n        node.model.lanes.splice(index, 1);\n      } else {\n        this.deleteSearchNode(node1, nodeId);\n      }\n    });\n  }\n}\n\nexport default Node;","import Node from './Node';\n\nexport default Node;","\nimport { isEqual, getNodeId, yExtraSpace, xExtraSpace, determineBoundBox, getColor } from './utils';\n\nexport { isEqual, getNodeId, yExtraSpace, xExtraSpace, determineBoundBox, getColor };","\n/**\n * Compares two strings in lowercase\n *\n * @export\n * @param {string} value the value to be compared\n * @param {string} compareTo whom the value would be compared\n * @return {boolean} true if values are equal\n */\nfunction isEqual(value, compareTo) {\n  if (typeof value !== 'string' || typeof compareTo !== 'string') {\n    throw new TypeError('value and compareTo must be string');\n  }\n  return value.toLowerCase() === compareTo.toLowerCase();\n}\n\nconst getNodeId = (() => {\n  let _uid = 0;\n  return () => `node-${++_uid}`;\n})();\n\nfunction yExtraSpace(node) {\n  let smallestHeight = 0;\n  if (node.getCutType() === 'v') {\n    smallestHeight = smallestExtraHeightHorizontally(node); // eslint-disable-line no-use-before-define\n  } else if (node.getCutType() === 'h') {\n    node.children.forEach(child => {\n      smallestHeight += yExtraSpace(child);\n    });\n  } else if (node.model.host && node.model.host.getLogicalSpace) {\n    let containerHeight = node.boundBox.height;\n    let hostHeight = node.model.host.getLogicalSpace().height;\n\n    smallestHeight = containerHeight - hostHeight;\n    if (smallestHeight < 0) {\n      smallestHeight = 0;\n    }\n  } else {\n    smallestHeight = 0;\n  }\n  return smallestHeight;\n}\n\nfunction smallestExtraHeightHorizontally(node) {\n  let smallestHeight = Number.MAX_SAFE_INTEGER;\n  node.children.forEach(child => {\n    let h = yExtraSpace(child);\n    if (h < smallestHeight) {\n      smallestHeight = h;\n    }\n  });\n  return smallestHeight;\n}\n\nfunction xExtraSpace(node) {\n  let smallestWidth = 0;\n  if (node.getCutType() === 'h') {\n    smallestWidth = smallestExtraWidthVertically(node); // eslint-disable-line no-use-before-define\n  } else if (node.getCutType() === 'v') {\n    node.children.forEach(child => {\n      smallestWidth += xExtraSpace(child);\n    });\n  } else if (node.model.host && node.model.host.getLogicalSpace) {\n    let containerWidth = node.boundBox.width;\n    let hostWidth = node.model.host.getLogicalSpace().width;\n    smallestWidth = containerWidth - hostWidth;\n    if (smallestWidth < 0) {\n      smallestWidth = 0;\n    }\n  } else {\n    smallestWidth = 0;\n  }\n  return smallestWidth;\n}\n\nfunction smallestExtraWidthVertically(node) {\n  let smallestWidth = Number.MAX_SAFE_INTEGER;\n  node.children.forEach(child => {\n    let w = xExtraSpace(child);\n    if (w < smallestWidth) {\n      smallestWidth = w;\n    }\n  });\n  return smallestWidth;\n}\n\nfunction determineBoundBox(bb, i, arr, instance) {\n  if (i) {\n    // if not first sibling, take boundbox from previous sibling\n    let lastSibling = arr[i - 1];\n    return {\n      width: bb.width,\n      height: bb.height,\n\n      top: instance._parentCut === 'h' ? lastSibling.boundBox.top + lastSibling.boundBox.height : lastSibling.boundBox.top,\n\n      left: instance._parentCut === 'h' ? lastSibling.boundBox.left : lastSibling.boundBox.left + lastSibling.boundBox.width\n    };\n  }\n  // if first sibling, take boundbox from parent\n  return {\n    width: bb.width,\n    height: bb.height,\n    top: instance.parent.boundBox.top,\n    left: instance.parent.boundBox.left\n  };\n}\n\nexport { isEqual, getNodeId, yExtraSpace, xExtraSpace, determineBoundBox, smallestExtraWidthVertically, smallestExtraHeightHorizontally };","export class LayoutDef {\n  constructor() {\n    this.componentMap = new Map();\n    this.layoutDefinition = null;\n  }\n\n  addComponent(name, component) {\n    this.componentMap.set(name, component);\n  }\n\n  set layoutDefinition(def) {\n    this._layoutDefinition = def;\n  }\n\n  get layoutDefinition() {\n    return this._layoutDefinition;\n  }\n\n  addMultipleComponent(componentArray) {\n    componentArray.forEach(comp => {\n      this.addComponent(comp.componentName, comp);\n    });\n  }\n\n  getSanitizedDefinition() {\n    this.sanitizeConfig(this.layoutDefinition);\n    return this.layoutDefinition;\n  }\n\n  sanitizeConfig(hostObj) {\n    if (hostObj.lanes && hostObj.lanes.length) {\n      hostObj.lanes.forEach(childHost => this.sanitizeConfig(childHost));\n    }\n    if (hostObj.host != null && typeof hostObj.host === 'string') {\n      if (this.componentMap.get(hostObj.host) !== undefined) {\n        hostObj.host = this.componentMap.get(hostObj.host);\n      }\n    }\n  }\n\n  getComponentMap() {\n    return this.componentMap;\n  }\n}","import { LayoutModel } from '../layout-definition';\n\nimport DefinitionManager from '../layout-definition/definition-manager';\n\nimport { DEFAULT_WIDTH, DEFAULT_HEIGHT, LAYOUT_NAME } from '../constants/defaults';\n\nimport { DrawingManager } from '../drawing-manager/drawingManager';\nimport { Utils } from '../utils/utils';\nimport { LayoutDef } from './layout-def';\nimport { DummyComponent } from '../layout-component';\n\nclass LayoutManager {\n  constructor(conf) {\n    this.renderAt = conf.renderAt;\n    this.width = conf.width || DEFAULT_WIDTH;\n    this.height = conf.height || DEFAULT_HEIGHT;\n    this.skeletonType = conf.skeletonType || 'html';\n    this.layoutDefinition = null;\n    this.layoutDef = new LayoutDef();\n    if (Utils.isDOMElement(this.renderAt)) {\n      this.renderAt._layout = this;\n    } else {\n      document.getElementById(this.renderAt)._layout = this;\n    }\n  }\n\n  compute() {\n    Utils.removeDiv(LAYOUT_NAME);\n    this.layoutDefinition = this.calLayOutDef();\n    this.layoutDef.layoutDefinition = this.layoutDefinition;\n    this.layoutDefinition = this.layoutDef.getSanitizedDefinition();\n    this._layout = new LayoutModel({\n      width: this.width,\n      height: this.height\n    }, this.layoutDefinition);\n    this.tree = this._layout.negotiate().tree();\n    this._layout.broadcast();\n    this.manager = new DrawingManager({ 'tree': this.tree, 'componentMap': this.layoutDef.getComponentMap() }, this.skeletonType, this.renderAt);\n\n    // this will draw all the components by calling their draw method\n    this.manager.draw();\n  }\n\n  // this will auto generate the layout definition\n  calLayOutDef() {\n    let defManager = new DefinitionManager(this.layoutDef.getComponentMap(), this.height, this.width);\n    let genLayoutdef = defManager.generateConfigModel();\n    return genLayoutdef;\n  }\n  addComponent(component) {\n    this.layoutDef.addComponent(component);\n  }\n\n  addMultipleComponent(componentArray) {\n    this.layoutDef.addMultipleComponent(componentArray);\n  }\n\n  resetNode(node) {\n    if (this.con) {\n      this.con.resetNode(node);\n    }\n  }\n\n  /**\n   * function to update the node and rerender the layout.\n   * @param  {} config - node configuration to change.\n   */\n  updateNode(config) {\n    this.tree.updateNode(config);\n    this.layoutDefinition = this.tree.model;\n    this.compute();\n  }\n\n  /**\n   * This method will be private and only be used to create\n   * layout components for default chart components such as title,legend etc\n   * @param {Array<{component,name}>} rawComponents : List of Component to be added\n   */\n  _createLayoutComponents(rawComponentsContainer) {\n    let layoutComponents = [];\n    // create dummy components and add them\n    rawComponentsContainer.forEach(container => {\n      let dummy = new DummyComponent(0, container.component.getLogicalSpace());\n      dummy.component = container.component;\n      dummy.componentName = container.name;\n      dummy.target = 'canvas';\n      dummy.seed = 10;\n      dummy.position = container.component.position;\n      dummy.alignment = container.component.alignment;\n      dummy.alignWidth = container.component.alignWidth;\n      layoutComponents.push(dummy);\n    });\n    this.registerComponents(layoutComponents);\n  }\n\n  /**\n  * This function takes the LayoutComponents and Register them in component store\n  * @param {Array<LayoutComponent>} layoutComponents\n  */\n  registerComponents(layoutComponents) {\n    this.addMultipleComponent(layoutComponents);\n  }\n}\n\nexport default LayoutManager;","import { HTMLDataAdapter } from '../data-adapters/html-data';\nimport { Utils } from '../utils/utils';\nimport { Renderer } from './renderer';\nimport { LAYOUT_NAME } from '../constants/defaults';\nexport class HTMLRenderer extends Renderer {\n  constructor(data) {\n    super();\n    this.data = data;\n    this.coordinates = new HTMLDataAdapter(this.data).getCoordinates();\n  }\n\n  createhtml(id) {\n    let mainDiv = document.getElementById(id);\n    super.initRenderer(mainDiv, this.data); // Initialise node with layout id\n    this.parentDiv = this.createAndCustomiseParent();\n    this.coordinates.forEach(node => {\n      this.parentDiv.appendChild(this.createAndPositionDiv(node));\n    });\n    mainDiv.appendChild(this.parentDiv);\n  }\n\n  createAndPositionDiv(node) {\n    let div = document.createElement('div');\n    div.style.position = 'absolute';\n    div.style.left = node.left + 'px';\n    div.style.top = node.top + 'px';\n    div.style.height = node.height + 'px';\n    div.style.width = node.width + 'px';\n    div.style.border = '1px dotted red';\n    // Utils.hoverHandler(div)\n    div.id = node._id;\n    return div;\n  }\n\n  createAndCustomiseParent() {\n    let container = Utils.findContainer(this.coordinates);\n    let parentDiv = this.createAndPositionDiv(container);\n    parentDiv.id = LAYOUT_NAME;\n    parentDiv.style.position = 'relative';\n    return parentDiv;\n  }\n}","/* eslint no-useless-constructor: \"off\" */\nimport { LAYOUT_ID } from '../constants/defaults';\n\nexport class Renderer {\n  constructor() {}\n\n  initRenderer(node, tree) {\n    node.className = LAYOUT_ID;\n    node.__logicalTree = tree;\n  }\n}","/* eslint no-undef: \"off\" */\nimport { DEFAULT_BORDER_COLOR, DEFAULT_BORDER_WIDTH } from '../constants/defaults';\n\nexport class Utils {\n  static onHover(event) {\n    this.highLightNode(event.target, DEFAULT_BORDER_COLOR, DEFAULT_BORDER_WIDTH);\n  }\n\n  static offHover(event) {\n    this.unHighLightNode(event.target);\n  }\n\n  static htmlHover(node, color, width) {\n    color = color !== undefined ? color : DEFAULT_BORDER_COLOR;\n    width = width !== undefined ? width : DEFAULT_BORDER_WIDTH;\n    node.style.outline = `${color} solid ${width}`;\n  }\n\n  static htmlUnHover(node) {\n    node.style.outline = '';\n  }\n\n  static highLightNode(node, color, width) {\n    let renderer = global.__renderer;\n\n    switch (renderer) {\n      case 'html':\n        this.htmlHover(node, color, width);\n        break;\n    }\n  }\n\n  static unHighLightNode(node) {\n    let renderer = global.__renderer;\n    switch (renderer) {\n      case 'html':\n        this.htmlUnHover(node);\n        break;\n    }\n  }\n\n  static hoverHandler(container) {\n    container.addEventListener('mouseover', this.onHover.bind(this));\n    container.addEventListener('mouseleave', this.offHover.bind(this));\n  }\n\n  static isDOMElement(element) {\n    return element instanceof Element;\n  }\n\n  static getID(element) {\n    return element.id;\n  }\n\n  static findContainer(data) {\n    return data.filter(coordinate => {\n      return coordinate.parent == null;\n    })[0];\n  }\n  /**\n   * static method to remove the div\n   * @param  {} divId - div ID to be removed.\n   */\n  static removeDiv(divId) {\n    if (document.getElementById(divId) !== null) {\n      document.getElementById(divId).remove();\n    }\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtHA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;ACDA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrJA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpGA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3GA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;A","sourceRoot":""}